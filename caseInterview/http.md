## 网络篇

### 1、TCP 和 UDP
#### TCP
  概念：传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送  
  特点：
    1、TCP充分地实现了数据传输时各种控制功能，可以进行丢包是重发控制，还可以对次序乱掉的分包进行顺序控制  
    2、TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费  
    3、根据TCP的这些机制，在IP这种无连接的网络上也能够实现高可靠性的通信(主要通过检测和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现)

#### UDP
  概念：用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层  
  特点：
  1、UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务  
  2、传输途中出现丢包，UDP也不负责重发  
  3、当包的到达顺序出现乱序时，UDP没有纠正的功能  
  4、并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP也无法进行流量控制等避免网络拥塞行为

  区别： 

  | 名称        | TCP                         | UDP |
  | ----       | ----                        | ---- |
  | 可靠性      | 可靠                         | 不可靠 |
  | 连接性      | 面向连接                      | 无连接 |
  | 报  文      | 面向字节流                    | 面向报文 |
  | 效  率      | 传输效率低                    | 传输效率高 |
  | 双共性      | 全双工                        | 一对一、一对多、多对一、多对多 |
  | 流量控制     | 滑动窗口                      | 无 |
  | 拥塞控制     | 慢开始、拥塞避免、快重传、快恢复  | 无 |
  | 传输效率     | 慢                           | 快 |

  1、TCP 是面向连接的协议，建立连接三次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接。发送端只负责将数据发送到网络，接收端从消息队列读取  
  2、TCP 提供可靠的服务，传输过程采用流量控制、编号与确定、计时器等手段确保数据无差错，不丢失。UDP则尽可能传输数据，单不保证传递交付给对方  
  3、TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新配置。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用  
  4、TCP 只能点对点全双工通信。UDP支持一对一、一对多、对多一和多对多的交互通信

  eg：
          应用层协议       应用
    TCP：
          SMTP           电子邮件
          TELNET         远程终端接入
          HTTP           万维网
          FTP            文件传输
    UDP:
          DNS            域名转换
          TFTP           文件传输
          SNMP           网路管理
          NFS            远程服务器

TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景

### 2、OSI 七层模型
+ 应用层
  位于OSI参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用
+ 表示层
  使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务
+ 会话层
  负责建立、管理和终止表示层实体之间的通信会话
+ 传输层
  传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题
  传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。其中，主要的传输层协议是UDP和TCP
+ 网络层
  主要任务是选择合适的网间路由和交换节点，确保数据按时成功传送
  在发送数据时。网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层
+ 数据链路层
  数据链路层通常也叫做链路层。在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议
+ 物理层
  作为OSI参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送
  该层的主要任务是确定与传输媒体的接口的一些特性(机械特性、电气特性、功能特性、过程特性)
  该层主要是和硬件有关，与软件关系不大

### 3、TCP、IP四层模型
* 应用层
* 传输层
* 网络层
* 数据链路层

### 4、HTTP1.0/1.1/2.0 区别
+ HTTP1.0
  * 仅仅提供了最简单的认证，这时候用户名和密码还未经加密
  * 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接
  * 不支持断点续传，每次都会传送全部的页面和数据
+ HTTP1.1
  默认支持长连接，即在一个TCP连接上可以传送多个HTTP请求和响应。减少了建立和关闭连接的消耗和延迟
    * 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
    * 在同一个TCP连接里面，客户端可以同时发送多个请求
    * 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
    * 新增了一些请求方法
    * 新增了一些请求头和响应头
+ HTTP2.0
  性能有很大的提升，如添加的特性：
    * 采用二进制格式而非文本格式
    * 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
    * 使用报头压缩，降低开销
    * 服务器推送

### 5、http 状态码
* 1 表示消息
  + 100（客户端继续发送请求，这是临时响应）Continue表示继续，一般在发送post请求时，已发送了 HTTP header之后，服务器端将返回此信息，表示确认，之后发送具体参数信息。
  + 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级
* 2 表示成功
  + 200（成功）OK表示正常返回信息。
  + 201（已创建）Created表示请求成功并且服务器创建了新的资源。
  + 202（已创建）Accepted表示服务器已接受请求，但尚未处理。
  + 203（非授权信息）服务器已成功处理请求，但返回的信息可能来自另一来源
  + 204（无内容）服务器成功处理请求，但没有返回任何内容
  + 205（重置内容）服务器成功处理请求，但没有返回任何内容
  + 206（部分内容）服务器成功处理了部分请求
* 3 表示重定向
  + 300（多种选择）针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
  + 301（永久移动）Moved Permanently表示请求的网页已永久移动到新位置
  + 302（临时移动）Found表示临时性重定向
  + 303（查看其他位置）See Other表示临时性重定向，且总是使用GET请求新的URI
  + 304 Not Modified表示自从上次请求后，请求的网页未修改过
  + 305（使用代理）请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
  + 307（临时重定向）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
* 4 表示请求错误
  + 400（错误请求）服务器不理解请求的语法
  + 401（未授权）请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  + 403（禁止）服务器拒绝请求
  + 404（未找到）服务器找不到请求的网页
  + 405（方法禁用）禁用请求中指定的方法
  + 406（不接受）无法使用请求的内容特性响应请求的网页
  + 407（需要代理授权）此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
  + 408（请求超时）服务器等候请求时发生超时
* 5 表示服务器错误
  + 500（服务器内部错误）服务器遇到错误，无法完成请求
  + 501（尚未实施服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
  + 502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应
  + 503（服务不可用）服务器目前无法使用（由于超载或停机维护）
  + 504（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求
  + 505（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本

### 6、https是什么，具体流程
* HTTPS是在HTTP和TCP之间建立了一个安全层，HTTP与TCP通信的时候，必须先进过一个安全层，对数据包进行加密，然后将加密后的数据包传送给TCP，相应TCP必须将数据包解密，才能传给上面的HTTP

* 浏览器传输一个`client_random`和加密方法列表，服务器收到后，传给浏览器一个`server_random`、`加密方法列表`和`数字证书(包含_公钥)`，然后浏览器对数字证书进行合法验证，如果验证通过，则生成一个`pre_random`，然后用公钥加密传给服务器，服务器用`client_random`、`server_random`和`pre_random`，使用公钥加密生成`secret`，然后之后的传输使用这个`secret`作为秘钥来进行数据的解密

### 7、三次握手和四次挥手
* 三次握手
  + 为什么要进行三次握手：为了确认对方的发送和接受能力
  + 主要流程
    - 一开始双方处于CLOSED状态，然后服务端开始监听某个端口进入LISTEN状态
    - 然后客户端主动发起连接，发送SYN，然后自己变为SYN-SENT，seq=x
    - 服务端收到之后，返回SYN seq=y 和 ACK ack = x + 1(对于客户端发来的SYN)，自己变成SYN-REVD
    - 之后客户端再次发送ACK seq = x + 1，ack = y + 1 给服务端，自己变成ESTABLISHED状态，服务端收到ACK，也进入ESTABLISHED
    ```
      SYN需要对端确认，所以ACK的序列化要加一，凡是需要对端确认的，一点要消耗TCP报文的序列化
    ```
  + 为什么不是两次
    ```
      无法确认客户端的接受能力
    ```
    - 如果首先客户端发送了SYN报文，但是滞留在网络里，TCP以为丢包了，然后重传，两次握手建立了连接
    - 等到了客户端关闭连接了。但是之后这个包如果到达了服务端，那么服务端接收到了，然后发送相应的数据表，就建立了链接，但是此时客户端已经关闭连接了，所以带来了链接资源的浪费
* 四次挥手
  + 流程
    - 一开始都处于ESTABLISH状态，然后客户端发送FIN报文，按地上seq=p，状态变为FIN-WAIT-1
    - 服务端收到之后，发送ACK确认，ack = p + 1，然后进入CLOSE-WAIT状态
    - 客户端收到之后进入FIN-WAIT-2状态
    - 过了一会等数据处理完，再次发送FIN、ACK、seq = q，ack = p + 1，进入了LAST-ACK阶段
    - 客户端收到FIN之后，客户端收到之后进入TIME_WAIT(等待2MSL)，然后发送ACK给服务端ack = 1 + 1
    - 服务端收到之后进入CLOSED状态
  + 为什么需要等待 2MSL（Maximum Segement Lifetime）
    ```
      因为如果不等待的话，如果服务端还有很多数据包要给客户端发，且此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱，所以说最保险的方法就是等服务器发来的数据包都死翘翘了再启动新应用
    ```
    - 1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端
    - 1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达
  + 为什么是四次而不是三次  
    如果是三次的话，那么服务端的 ACK 和 FIN 合成一个挥手，那么长时间的延迟可能让 TCP 一位 FIN 没有达到服务器端，然后让客户的不断的重发 FIN
  + 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持  
    在HTTP中响应体的Connection字段指定为keep-alive
* 你对 TCP 滑动窗口  
  + TCP 滑动窗口分为两种: 发送窗口和接收窗口
  + 在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而经常会存在发送端发送过多，而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口

### 8、HTTP 如何实现长连接？在什么时候会超时  
通过在头部设置Connection: keep-alive，HTTP1.0协议支持，但是默认关闭，从HTTP1.1协议以后，连接默认都是长链接
* HTTP一般会有httpd守护进程，里面可以设置keep-alive timeout，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间
* TCP的keep-alive包含三个参数，支持在系统内核的net.ipv4里面设置：当TCP连接之后，闲置了tcp_keepalive_time，则会发生侦测包，如果没有收到对方的ACK，那么会每隔tcp_keepalive_intvl再发一次，直到发送了tcp_keepalive_probes，就会丢弃该连接
  + tcp_keepalive_intvl = 15
  + tcp_keepalive_probes = 5
  + tcp_keepalive_time = 1800
实际上HTTP没有长短连接，只有TCP有，TCP长连接可以复用一个TCP连接来发起多次HTT请求，这样可以减少资源消耗，比如一次请求 HTML，可能还需要请求后续的 JS/CSS/图片等

### 9、TCP 如何保证有效传输及拥塞控制原理
* 拥塞控制原理  
  原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了  
  主要用三种方法：  
    + 慢启动阈值 + 拥塞避免  
      在发送端使用拥塞窗口来控制发送窗口的大小。  
      然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接受窗口大小，然后初始化对方的拥塞窗口，接着每经过一轮PTT(收发延迟)，拥塞窗口大小翻倍，直到达到慢启动阈值  
      然后开始拥塞避免，拥塞避免具体的做法就是之前每一轮RTT，拥塞窗口翻倍，现在每一轮就加一  
    + 快速重传
      在 TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK，比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端受到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间）  
      选择性重传：报文首部可选性中加入 SACK 属性，通过 left edge 和 right edge 标志那些包到了，然后重传没到的包
    + 快速恢复
      如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段：
      - 会将拥塞阈值降低为 拥塞窗口的一半
      - 然后拥塞窗口大小变为拥塞阈值
      - 接着 拥塞窗口再进行线性增加，以适应网络状况

### 10、OPTION是干啥的？举个用到OPTION的例子
旨在发送一种探测请求，以确定针对某个目标地址的请求必须具有怎么样的约束，然后根据约束发送真正的请求。  
比如针对跨域资源的预检，就是采用 HTTP 的 OPTIONS 方法先发送的。用来处理跨域请求

### 11、http知道嘛？哪一层的协议？
* 优点
  + 灵活可扩展，除了规定空格分隔单词，换行分隔字段以外，其他都没有限制，不仅仅可以传输文本，还可以传输图片、视频等任意资源
  + 可靠传输，基于 TCP/IP 所以继承了这一特性
  + 请求-应答，有来有回
  + 无状态，每次 HTTP 请求都是独立的，无关的、默认不需要保存上下文信息
* 缺点：
  + 明文传输不安全
  + 复用一个 TCP 链接，会发生对头拥塞
  + 无状态在长连接场景中，需要保存大量上下文，以避免传输大量重复的信息

### 12、