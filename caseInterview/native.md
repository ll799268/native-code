## 原生篇

### 1、判断引用数据类型方法（内置 API、对象的 toString 方法、原型）
```js
  xx instanceof Type
  Object.prototype.toString.call(xx) === '[object Type]'
  xx.__proto__ === Type.prototype
  xx.constructor === Type
```

### 2、闭包
* 概念：
  函数在执行的时候会放到一个执行栈上执行，当函数执行完毕之后会在执行栈上移除
  但是由于堆上的成员因为被外部引用不能释放
  因此内部函数依然可以访问外部函数的成员
* 缺点：内存消耗很大，容易导致内存泄漏

### 3、设计模式
创建型模式(5)，工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式(7)，适配器模式、装饰器模式、代理模式、外观模式桥接模式、组合模式、享元模式
行为型模式(11)，策略模式、模板方法模式、观察者模式、选代子模式、責任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

* 单例模式 （singleton 挂在window执行, 用来减少重复创建对象）
* 工厂模式（factory 用来解耦）
* 观察者模式 （observer 用来收发消息）
* 策略模式（strategy 用来定义算法）
* 发布者订阅模式（vue）
* 装饰器模式（骨架 -> 装修）
* 建造者模式（建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。）

### 4、栈和堆的区别
* 栈（stack） 先进后出
  由编译器自动分配和释放，存放函数的参数值、局部变量的值等。
  基本数据类型存储的地方

* 堆（heap）
  一般由程序员分配和释放，若程序员不释放，程序结束时可能由OS回收。
  堆（数据结构）可以被看成一棵树，如堆排序。
  引用数据类型存储的地方

### 5、输入 url 发生了什么
+ DNS域名解析
  客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求
  如果没有，再去找DNS服务器。
+ 建立TCP连接（三次握手）
+ 发送HTTP请求
+ 服务器处理请求
+ 返回响应结果
+ 关闭TCP连接（四次挥手）
+ 浏览器解析HTML
  浏览器通过解析HTML，生成DOM树，解析CSS，生成CSSOM树，然后通过DOM树和CSSPOM树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。
+ 浏览器布局渲染
  根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。最后浏览器绘制各个节点，将页面展示给用户。

  replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
  reflow：意味着元素的几何尺寸变了，需要重新计算渲染树。

### 6、宏任务、微任务
* 宏任务：宏任务可以被理解为每次"执行栈"中所执行的代码，而浏览器会在每次宏任务执行结束后，在下一个宏任务执行开始前，对页面进行渲染，而宏任务包括：
  * script(整体代码)
  * setTimeout
  * setInterval
  * I/O
  * UI交互事件
  * postMessage
  * MessageChannel
  * setImmediate
  * UI rendering
* 微任务,可以理解是在当前"执行栈"中的任务执行结束后立即执行的任务。而且早于页面渲染和取任务队列中的任务。微任务包括：
  * Promise.then
  * Object.observe
  * MutaionObserver
  * process.nextTick

执行机制：
  + 执行一个宏任务（栈中没有就从事件队列中获取）
  + 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
  + 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
  + 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
  + 渲染完毕后，js线程继续接管，开始下一个宏任务（从事件队列中获取）

### 7、Set、Map 两种数据结构
Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构
集合 or 字典
  * 概念：
    + 集合：是由一堆无序的、相关联的，且不重复的内存结构[数学中称为元素]组成的组合
    + 字典：是一些元素的集合，每个元素有一个称作 key 的域，不同元素的 key 各不相同
  * 区别：
    + 共同点：集合、字典都可以存储不重复的值
    + 不同点：集合是以[值、值]的形式存储元素，字典是以[[键: 值]]的形式存储

### 8、内存泄漏
* 全局变量造成的内存泄漏
  + 未声明变量
  + 使用 this 创建的变量(this 的指向是 window)
* 闭包引起的内存泄漏
  将事件处理函数定义在外部，解除闭包 或者将定义事件处理函数在外部
* 没有清理的 DOM 元素引用
  手动删除，elements.btn = null
* 被遗忘的定时器或者是回调函数
  + 手动删除定时器和DOM
  + removeEventListener 移除事件监听

### 9、数据类型转换
* Number()
  + Number()将字符串转换为数值，要比parseInt函数严格。基本上，只要有一个字符无法转成数值，整个字符串就会被转换成NaN。但是，parseInt可以处理字符串截取和数值进制问题
  + 参数为对象类型：
    - 调用对象自身的valueOf方法，如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤
    - 如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对改值使用Nubmer函数，不再进行后续步骤
    - 如果toString方法返回的是对象，报错  
* String()
  + 当String()的参数为原始数据类型时：
    * 数值：转为对应的字符串
    * 字符串：转换后还是原来的值
    * 布尔值：true 转为字符串的'true'，false对应
    * undefined：转化为字符串 'undefined'
    * null：转化为字符串 'null'
  + 参数为对象类型：
    - 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤
    - 如果 toString 方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数。不再进行以下步骤
    - 如果valueOf方法返回的是对象，报错
* Bollean()
  在Bollean类型转换时，虚值(falsey)，虚值主要有以下几种：
    * undefined
    * null
    * 0 +0 -0
    * NaN
    * false
    * ''

### 10、正则表达式
* 从字符出发
  + 单个字符
    - 换行符 /n(hew line)
    - 回车符 /r(return)
    - 空白符 /s(space)
    - 制表符 /t(tab)
    - 换页符号 /f(form feed)
    - 垂直制表符 /v(vertical tab)
    - 回退符 [\b](backspace 避免和/b重复)
  + 多个字符
    - 除了换行符之外的任何字符 .
    - 单个数字[0-9] /d(digit)
    - 除了[0-9] /D(not digit)
    - 字母或数字或下划线或汉字[A-Za-z0-9_] /w(word)
    - 非单字字符 /W(not word)
    - 匹配空白字符，包括空格、制表符、换页符和换行符 /s(space)
    - 匹配非空白字符 /S(not space)
* 循环和重复
  + 元字符`*`用来表示匹配0个或无数个字符。通常用来过滤某些可有可以无的字符串
  + 元字符`+`适用于要匹配同个字符出现1次或者多次的情况
  + 特定次数
    ```js
      {x}: x次
      {min, max}: min-max
      {min, }: 至少min次
      {0, max}: 至多max次
    ```
* 位置边界
  + 单词边界
    ```
      The cat scattered his food all over the room
    ```
    我想找到cat这个单词，但是如果只是使用/cat/这个正则，就会同时匹配到cat和scattered这两处文本。
    这时候我们就需要使用边界正则表达式\b
    ```js
      /\bcat\b/
    ```
  + 字符串边界
    - 单词边界 \b(boundary)
    - 非单词边界 \B(not boundary)
    - 字符串开头 ^
    - 字符串结尾 $
    - 多行模式 m标志(multiple of lines)
    - 忽略大小写 i标志(ignore case, case-insensitive)
    - 全局模式 g标志(global)
* 子表达式
  通过嵌套递归和自身引用可以让正则发挥更强大的功能。  
  从简单到复杂的正则表达式演变通常要采用分组、回溯引用和逻辑处理的思想
  + 分组
    其中分组体现在：所有以`(`和`)`元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则的基础
  + 回溯引用
    - 引用 \0, \1, \2 和 $0, $1, $2
    - 非捕获组 (?:) 引用表达式(()), 本身不被消费(?), 引用(:)
    - 前向查找 (?=) 引用子表达式(()), 本身不被消费(?), 正向的查找(=)
    - 前向负查找 (?!) 引用子表达式(()), 本身不被消费(?), 负向的查找(!)
    - 反向查找 (?<=) 引用子表达式(()), 本身不被消费(?), 反向的(<，开口往后)，正的查找(=)
    - 反向查找 (?<!) 引用子表达式(()), 本身不被消费(?), 反向的(<，开口往后)，负的查找(!)
  + 逻辑处理
   - 非 [^regex] 和 !
   - 或 |