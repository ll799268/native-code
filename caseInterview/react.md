### 1、hook 钩子函数
+ `useState hook`
  * 让函数组件也可以有state状态，并进行状态数据的读写操作
  * 语法 const [data, setData] = useState(defaultVal)
  * useState()说明
      参数：第一次初始化指定的值在内部做缓存
      返回值：包含2个元素的数组，第一个为内部当前状态值，第二个为更新状态值的函数
  * setData()两种写法
    setData(newValue)：参数为非函数组值，直接指定新的状态值，内部用其覆盖原来的状态值
    setData(value => newValue)：参数作为函数，接受原本的状态值，返回新的状态值，内部用其覆盖原来的值

+ `useEffect hook`
  * 可以让你在函数组件中执行副作用(用于模拟生命周期的钩子)
  * react中的副作用操作：
      发送请求数据的获取
      设置订阅、启动定时器
      手动更改真实DOM
  * 语法和说明：
    useEffect(() => {
      在此可操作性任何带副作用的操作
      return () => { 在组件卸载前执行
        在此做一些收尾性的工作，取消订阅、清定时器
      }
    }, [stateValue]) 如果指定是[]，回调函数只会在第一次render后执行
  * 可以把useEffect Hook 看做是如下三个函数的结合
    componentDidMount()
    componentDidUpdate()
    componentWillUnmount()

+ `useRef hook`
  * 可以在函数组件中存储、查找组件内的标签或任意其他类型
  * 语法 const refDom = useRef() <input ref={ refDom } />
  * 使用 保存标签对象，功能和React.createRef()一样

### 2、Fiber 架构
* 问题：
  js引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待
  如果js线程长时间占用了主线程，那么渲染层面的更新就不得不长时间等待，界面长时间不断更新，会导致页面响应速度变差，用户可能会感觉到卡顿
* 特性：
  + 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新执行优先级低的任务
  + 增加了异步任务，调用requestldleCallback api，浏览器空闲的时候执行
  + dom diff 树变成了链表，一个dom对应两个fiber，对应两个队列，这都是为找到被中断的任务重新执行
从架构角度来看，Fiber 是对 React 核心算法(即调和过程)的重写
从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是对Fiber 树结构的节点单位，也就是React 16 新架构下的虚拟DOM
* 原理：
  + Fiber 把渲染任务更新过程拆分成多个子任务，每次只做一小部分，做完看是否有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续进行
  + 即可以中断和恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为React Element 对应的 Fiber 节点
  实现的方式的是 requestIdleCallback 方法：
    * window.requestIdleCallback() 方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入相应
  + 首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前React未完成的任务，是一种合作式调度
  + 该实现过程是基于 Fiber 节点实现，作为静态的数据结构来说，每个Fiber节点对应一个 React element，保存了该组件的类型(函数组件、类组件、原生组件等等)、对应的DOM节点等信息
  + 作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作