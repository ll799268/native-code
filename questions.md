# 知识点整理

## native js

### 1、判断引用数据类型方法（内置 API、对象的 toString 方法、原型）
```js
  xx instanceof Type
  Object.prototype.toString.call(xx) === '[object Type]'
  xx.__proto__ === Type.prototype
  xx.constructor === Type
```

### 2、闭包
概念：
  函数在执行的时候会放到一个执行栈上执行，当函数执行完毕之后会在执行栈上移除
  但是由于堆上的成员因为被外部引用不能释放
  因此内部函数依然可以访问外部函数的成员
缺点：内存消耗很大，容易导致内存泄漏

### 3、设计模式
创建型模式(5)，工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式(7)，适配器模式、装饰器模式、代理模式、外观模式桥接模式、组合模式、享元模式
行为型模式(11)，策略模式、模板方法模式、观察者模式、选代子模式、責任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

* 单例模式 （singleton 挂在window执行, 用来减少重复创建对象）
* 工厂模式（factory 用来解耦）
* 观察者模式 （observer 用来收发消息）
* 策略模式（strategy 用来定义算法）
* 发布者订阅模式（vue）
* 装饰器模式（骨架 -> 装修）
* 建造者模式（建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。）

### 4、栈和堆的区别
* 栈（stack） 先进后出
  由编译器自动分配和释放，存放函数的参数值、局部变量的值等。
  基本数据类型存储的地方

* 堆（heap）
  一般由程序员分配和释放，若程序员不释放，程序结束时可能由OS回收。
  堆（数据结构）可以被看成一棵树，如堆排序。
  引用数据类型存储的地方

### 5、输入 url 发生了什么
1、DNS域名解析
  客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求
  如果没有，再去找DNS服务器。
2、建立TCP连接（三次握手）
3、发送HTTP请求
4、服务器处理请求
5、返回响应结果
6、关闭TCP连接（四次挥手）
7、浏览器解析HTML
  浏览器通过解析HTML，生成DOM树，解析CSS，生成CSSOM树，然后通过DOM树和CSSPOM树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。
8、浏览器布局渲染
  根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。最后浏览器绘制各个节点，将页面展示给用户。

  replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
  reflow：意味着元素的几何尺寸变了，需要重新计算渲染树。

### 6、宏任务、微任务
* 宏任务：宏任务可以被理解为每次"执行栈"中所执行的代码，而浏览器会在每次宏任务执行结束后，在下一个宏任务执行开始前，对页面进行渲染，而宏任务包括：
  script(整体代码)
  setTimeout
  setInterval
  I/O
  UI交互事件
  postMessage
  MessageChannel
  setImmediate
  UI rendering
* 微任务,可以理解是在当前"执行栈"中的任务执行结束后立即执行的任务。而且早于页面渲染和取任务队列中的任务。微任务包括：
  Promise.then
  Object.observe
  MutaionObserver
  process.nextTick

执行机制：
  执行一个宏任务（栈中没有就从事件队列中获取）
  执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
  宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
  当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
  渲染完毕后，js线程继续接管，开始下一个宏任务（从事件队列中获取）

### 7、web 基础技术的优化
* 精灵图(sprite)，合并、压缩图片
* 减少 http 请求
* 懒加载、预加载
* 减少 iframe 使用
* 减少图片 src 为空
* 开启 gzip 压缩
* 浏览器缓存
* CND 使用
* 使用 Chorme Performance 查找性能瓶颈

### 8、Set、Map 两种数据结构
Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构
集合 or 字典
  概念：
    集合：是由一堆无序的、相关联的，且不重复的内存结构[数学中称为元素]组成的组合
    字典：是一些元素的集合，每个元素有一个称作 key 的域，不同元素的 key 各不相同
  区别：
    共同点：集合、字典都可以存储不重复的值
    不同点：集合是以[值、值]的形式存储元素，字典是以[[键: 值]]的形式存储

### 9、内存泄漏
* 全局变量造成的内存泄漏
  1、未声明变量
  2、使用 this 创建的变量(this 的指向是 window)
* 闭包引起的内存泄漏
  将事件处理函数定义在外部，解除闭包 或者将定义事件处理函数在外部
* 没有清理的 DOM 元素引用
  手动删除，elements.btn = null
* 被遗忘的定时器或者是回调函数
  1、手动删除定时器和DOM
  2、removeEventListener 移除事件监听

## 网络

### 1、TCP 和 UDP
* TCP
  概念：传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送
  特点：
    1、TCP充分地实现了数据传输时各种控制功能，可以进行丢包是重发控制，还可以对次序乱掉的分包进行顺序控制
    2、TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费
    3、根据TCP的这些机制，在IP这种无连接的网络上也能够实现高可靠性的通信(主要通过检测和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现)

* UDP：
  概念：用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层
  特点：
    1、UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务
    2、传输途中出现丢包，UDP也不负责重发
    3、当包的到达顺序出现乱序时，UDP没有纠正的功能
    4、并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP也无法进行流量控制等避免网络拥塞行为

区别：
                TCP                           UDP
  可靠性       可靠                          不可靠
  连接性       面向连接                       无连接
  报  文       面向字节流                     面向报文
  效  率       传输效率低                     传输效率高
  双共性       全双工                         一对一、一对多、多对一、多对多
  流量控制      滑动窗口                       无
  拥塞控制      慢开始、拥塞避免、快重传、快恢复   无
  传输效率      慢                            快

1、TCP 是面向连接的协议，建立连接三次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接。发送端只负责将数据发送到网络，接收端从消息队列读取
2、TCP 提供可靠的服务，传输过程采用流量控制、编号与确定、计时器等手段确保数据无差错，不丢失。UDP则尽可能传输数据，单不保证传递交付给对方
3、TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新配置。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
4、TCP 只能点对点全双工通信。UDP支持一对一、一对多、对多一和多对多的交互通信

eg：
        应用层协议       应用
  TCP：
        SMTP           电子邮件
        TELNET         远程终端接入
        HTTP           万维网
        FTP            文件传输
  UDP:
        DNS            域名转换
        TFTP           文件传输
        SNMP           网路管理
        NFS            远程服务器

TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景

### 2、OSI 七层模型
1、应用层
  位于OSI参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用
2、表示层
  使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务
3、会话层
  负责建立、管理和终止表示层实体之间的通信会话
4、传输层
  传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题
  传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。其中，主要的传输层协议是UDP和TCP
5、网络层
  主要任务是选择合适的网间路由和交换节点，确保数据按时成功传送
  在发送数据时。网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层
6、数据链路层
  数据链路层通常也叫做链路层。在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议
7、物理层
  作为OSI参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送
  该层的主要任务是确定与传输媒体的接口的一些特性(机械特性、电气特性、功能特性、过程特性)
  该层主要是和硬件有关，与软件关系不大

### 3、HTTP1.0/1.1/2.0 区别
1、HTTP1.0
  浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接
2、HTTP1.1
  默认支持长连接，即在一个TCP连接上可以传送多个HTTP请求和响应。减少了建立和关闭连接的消耗和延迟
  1、引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
  2、在同一个TCP连接里面，客户端可以同时发送多个请求
  3、虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
  4、新增了一些请求方法
  5、新增了一些请求头和响应头
3、HTTP2.0
  性能有很大的提升，如添加的特性：
    1、采用二进制格式而非文本格式
    2、完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
    3、使用报头压缩，降低开销
    4、服务器推送

### 4、http 状态码
* 1 表示消息
  100（客户端继续发送请求，这是临时响应）Continue表示继续，一般在发送post请求时，已发送了 HTTP header之后，服务器端将返回此信息，表示确认，之后发送具体参数信息。
  101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级
* 2 表示成功
  200（成功）OK表示正常返回信息。
  201（已创建）Created表示请求成功并且服务器创建了新的资源。
  202（已创建）Accepted表示服务器已接受请求，但尚未处理。
  203（非授权信息）服务器已成功处理请求，但返回的信息可能来自另一来源
  204（无内容）服务器成功处理请求，但没有返回任何内容
  205（重置内容）服务器成功处理请求，但没有返回任何内容
  206（部分内容）服务器成功处理了部分请求
* 3 表示重定向
  300（多种选择）针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
  301（永久移动）Moved Permanently表示请求的网页已永久移动到新位置
  302（临时移动）Found表示临时性重定向
  303（查看其他位置）See Other表示临时性重定向，且总是使用GET请求新的URI
  304 Not Modified表示自从上次请求后，请求的网页未修改过
  305（使用代理）请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
  307（临时重定向）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
* 4 表示请求错误
  400（错误请求）服务器不理解请求的语法
  401（未授权）请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  403（禁止）服务器拒绝请求
  404（未找到）服务器找不到请求的网页
  405（方法禁用）禁用请求中指定的方法
  406（不接受）无法使用请求的内容特性响应请求的网页
  407（需要代理授权）此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
  408（请求超时）服务器等候请求时发生超时
* 5 表示服务器错误
  500（服务器内部错误）服务器遇到错误，无法完成请求
  501（尚未实施服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
  502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应
  503（服务不可用）服务器目前无法使用（由于超载或停机维护）
  504（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求
  505（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本

## vue

### 1、双向绑定的实现原理
Observer(观察者)对初始数据通过Object.defineProperty添加setter、getter，
当取数据(即调用get)的时候添加订阅对象(wachter)到数组里，
当给数据赋值(即调用set)的时候就能知道数据的变化，
此时调用发布订阅中心，从而遍历当前数据的订阅数组，执行里面所有的watcher，通知变化

### 2、vue2 中 defineProperty 和 vue3 中 proxy 区别
Object.defineProperty(obj, key, descriptor)
缺点： 
  1、无法监听数组的变化
  2、修改属性值的时候需要遍历对象再修改

watcher = new Proxy(tarage, handler)
优点： 
  1、可以直接监听数组的变化
  2、返回的是一个新对象，可以操作新的对象达到目的
缺点：兼容性问题

### 3、vue 中的 directive
生命周期：
  bind函数：只调用一次，指令第一次绑定在元素上调用，即初始化调用一次，
  inserted函数：并绑定元素插入父级元素（即new vue中el绑定的元素）时调用（此时父级元素不一定转化为了dom）
  update函数：在元素发生更新时就会调用，可以通过比较新旧的值来进行逻辑处理
  componentUpdated函数：元素更新完成后触发一次
  unbind函数：在元素所在的模板删除的时候就触发一次

钩子函数对应的参数el, binding, vnode, oldnode, 具体参数讲解如下：
  a、el指令所绑定的元素 可以直接操组dom元素
  b、binding一个对象，具体包括以下属性：
    1）name：定义的指令名称 不包括v-
    2）value：指令的绑定值，如果绑定的是一个计算式，value为对应计算结果
    3）oldvalue：指令绑定元素的前一个值，只对update和componentUpdated钩子函数有值
    4）expression：指令绑定的原始值 不对值进行任何加工
    5）arg：传递给指令的参数
    6）modifiers：指令修饰符，如：v-focus.show.async 则接收的 modifiers 为｛ show：true，async：true ｝
  c、vnode：vue编译生成的虚拟dom
  d、oldVnode：上一个 vnode，只在 update 和 componentUpdated 钩子函数中有效

### 4、keep-alive
第一次进入，钩子的触发顺序: created-> mounted-> actived
当再次进入（前进或者后退）时，只触发 actived 事件挂载的方法、router 的 beforeRouteEnter
只执行一次的放在 mounted 中；组件每次进去执行的方法放在 actived 中
  1）include - 字符串或正则表达式，只有名称匹配的组件会被缓存
  2）exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存
  3）include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind
！！！ 服务端不会执行 actived 方法

### 5、vue-router
1、路由守卫钩子
  全局守卫
    * beforeEach(to, from, next)
    * afterEach(to, from, next)
  局部守卫
    * beforeRouteEnter(to, from, next)
    * beforeRouteUpdate(to, from, next)
    * beforeRouteLeave(to, from, next)
2、路由原理
  hash模式（hashchange）
    url 改变的时候 会触发 hashchange 事件
  history模式（popstate）
    通过浏览器前进后退改变 URL 时会触发 popstate 事件
    通过pushState、replaceState、<a>标签改变 URL 不会触发 popstate 事件。
    好在我们可以拦截 pushState、replaceState的调用和<a>标签的点击事件来检测 URL 变化
    通过js 调用history的back，go，forward方法课触发该事件

### 6、vuex
1、概念
  vuex 是一个专为 Vue.js 应用程序开发的状态管理模式
2、核心概念
  五大属性：state, getter, mutation, action, module
    state: 存储数据、状态，在根实例注册了store, 用 this.$store.state 来访问
    getter: 计算状态属性，返回值会被缓存起来，当它的依赖发生变化会重新计算
    mutation: 更改 state 中的唯一方法
    action: 包含任意的异步操作，提交 mutation 改变状态，而不是直接改变状态
    module: 将 store 分割成模块，每个模块都有state、getter、mutation、action 甚至是嵌套子模块
3、流程
    dispath    commit
action => mutation => state
4、持久化工具
  vuex-persistedstate

### 7、v-for 和 v-if 优先级
2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用
3.x 版本中 v-if 总是优先于 v-for 生效
迁移策略
  由于语法上存在歧义，建议避免在同一元素上同时使用两者。
  比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素

### 8、Vue.nextTick
在下次 DOM 更新循环结束之后执行延迟回调
在修改数据之后立即使用这个方法，获取更新后的 DOM

### 9、Vue 项目的优化（代码层面的优化）
* v-if 和 v-show 区分使用场景
* computed 和 watch 区分使用场景
* v-for 遍历必须为 item 添加 key，同时避免使用 v-if
* 长列表的性能优化
* 事件的销毁
* 图片资源懒加载
* 路由懒加载
* 第三方插件按需加载
* 优化无限列表性能
* 服务端渲染 SSR 或者预加载

### 10、computed 和 watch 的区别和运用的场景
区别：
  computed 计算属性，依赖 data 属性值，有缓存的。只有他的依赖属性值发生改变，下一次获取的值会重新计算
  watch 观察作用，类似于某些数据的监听回调，每当监听的数据发生改变会执行后续操作
运用场景：
  computed 当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed 因为可以利用缓存机制，避免每次获取值时，都需要重新计算
  watch 当我们需要数据变化时执行异步或者开销较大的操作时候，应该使用它
    使用它选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。

### 11、父子组件生命周期执行顺序

```js
  // 1、挂载阶段
    beforeCreate(父) -> created(父) -> beforeMount(父) -> beforeCreate(子) -> created(子) -> beforeMount(子) -> mounted(子) -> mounted(父)
  // 2、子组件更新阶段
    beforeUpdate(父) -> beforeUpdate(子) -> updated(子) -> updated(父)
```

### 12、生命周期

```js
  // 创建实例（vm）
  `beforeCreate`:
    initLifecycle(vm) // 初始化组件生命周期标志位
    initEvents(vm) // 初始化事件监听
    initRender(vm) // 初始化渲染方法
    callHook(vm, 'beforeCreate')
    // 初始化依赖注入内容，在初始化data、props之前
    initInjections(vm) // resolve injections before data/props
    initState(vm) // 初始化props、data、method、watch、methods
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

  // 实例完成 observer(数据观测) 和 property（传入的prop数据） 和方法的运算
  `created`:

  // 在挂载开始之前被调用 相关的 render 函数首次被调用
  `beforeMount`:

  // 实例被挂载后调用，这时的 el 被创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，被调用的 vm.$el 也是在文档内
  `mounted`:

  // 数据更新时调用，发生在虚拟 DOM 打补丁之前，这里适合在更新之前访问现有的 DOM 比如手动移除已添加的事件监听
  `beforeUpdate`:

  // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
  // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。
  `updated`:

  // 被 keep-alive 缓存的组件激活时调用(该钩子在服务器端渲染期间不被调用)
  `active`:

  // 实例销毁之前调用。在这一步，实例仍然完全可用(该钩子在服务器端渲染期间不被调用)
  `beforedDestroy`:

  // 实例销毁之后调用。该钩子被调用后，对应的 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁(该钩子在服务器端渲染期间不被调用)
  `destroyed`:

```

### 13、new Vue 的步骤
1、`new Vue` 的时候会调用 _init 方法
  * 定义 `$set`、`$get`、 `$delete`、`$watch` 等方法
  * 定义 `$on`、`$off`、`$emit` 等事件
  * 定义 _update、$forceUpdate、$destroy 生命周期

2、调用 `$mount` 进行页面的挂载
3、挂载的时候主要是通过 `mountComponent` 方法
4、定义 `updateComponent` 更新函数
5、执行 `render` 生成虚拟 `DOM`
6、`_update` 将虚拟 `DOM` 生成真实的 `DOM` 结构，并渲染到页面中

### 14、Vue 中给对象添加新属性界面不刷新
原因：Vue 不允许在已经创建的实例动态添加新的响应式属性，若想实现数据与视图同步更新，可采用：
  * 如果为对象添加少量的新属性，可以直接采用 Vue.set(orginObj, key, vaule)
  * 如果需要为新对象添加大量的新属性，则通过 Object.assign({}, originObj, { key: value }) 创建新对象
  * 如果实在不知道怎么操作时，可采用 $forceUpdate() 进行强制刷新

### 14、Vue 中 mixin 的理解和应用场景
概念:
  本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods 、created、computed 等
  我们只要将共用的功能以对象的方式传入 mixins 选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来
  在 Vue 中我们可以局部混入和全局混入
应用场景:
  在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立

### 15、v-for 中的 key
key 是给每一个 vnode 的唯一 id，也是diff的一种优化策略，可以根据 key 更准确，更快找到 vnode 节点
  如果不用 key, Vue 会采用就地复地原则：最小化 element 的移动，并且会尝试最大程度在同适当位置对相同类型的 element 做 patch 或者 reuse
  如果使用了 key, Vue 会根据 key 的顺序记录 element, 曾经拥有了 key 的 element 如果不再出现的话，会被直接 remove 或者 destoryed

### 16、diff 算法
1、概念特点：
  diff 算法是一种通过同层的树节点进行比较的高级算法
  比较只会在同层进行，不会跨层级比较
  在diff比较过程中 循环从两边向中间比较
  diff 算法在很多场景都有使用，在 vue 中，作用域虚拟 dom 渲染成真实的 dom 的新旧 VNode 节点比较
2、比较方式
  diff 整体策略：深度优先，同层比较
  * 比较会在同层级进行，不会跨层级比较
  * 比较过程中，循环从两边向中间收拢

### 16、无法检测对象 property 的添加或者移除

原因：
由于 JavaScript(ES5) 的限制，Vue.js 不能检测到对象属性 的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的
解决办法

```js
  // 动态添加单个
  Vue.set(vm.obj, propertyName, newValue)
  vm.$set(vm.obj, propertyName, newValue)

  // 动态添加多个
  this.obj = Object.assign({}, this.obj, {a: 1, b: 2})

  // 动态移除
  Vue.delete(vm.obj, propertyName/index)
  vm.$set(vm.obj, propertyName/index)
```

## react

### 1、hook 钩子函数
1、`useState hook`
  * 让函数组件也可以有state状态，并进行状态数据的读写操作
  * 语法 const [data, setData] = useState(defaultVal)
  * useState()说明
      参数：第一次初始化指定的值在内部做缓存
      返回值：包含2个元素的数组，第一个为内部当前状态值，第二个为更新状态值的函数
  * setData()两种写法
    setData(newValue)：参数为非函数组值，直接指定新的状态值，内部用其覆盖原来的状态值
    setData(value => newValue)：参数作为函数，接受原本的状态值，返回新的状态值，内部用其覆盖原来的值

2、`useEffect hook`
  * 可以让你在函数组件中执行副作用(用于模拟生命周期的钩子)
  * react中的副作用操作：
      发送请求数据的获取
      设置订阅、启动定时器
      手动更改真实DOM
  * 语法和说明：
    useEffect(() => {
      在此可操作性任何带副作用的操作
      return () => { 在组件卸载前执行
        在此做一些收尾性的工作，取消订阅、清定时器
      }
    }, [stateValue]) 如果指定是[]，回调函数只会在第一次render后执行
  * 可以把useEffect Hook 看做是如下三个函数的结合
    componentDidMount()
    componentDidUpdate()
    componentWillUnmount()

3、`useRef hook`
  * 可以在函数组件中存储、查找组件内的标签或任意其他类型
  * 语法 const refDom = useRef() <input ref={ refDom } />
  * 使用 保存标签对象，功能和React.createRef()一样

### 2、Fiber 架构
问题：
  js引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待
  如果js线程长时间占用了主线程，那么渲染层面的更新就不得不长时间等待，界面长时间不断更新，会导致页面响应速度变差，用户可能会感觉到卡顿
特性：
  1、为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新执行优先级低的任务
  2、增加了异步任务，调用requestldleCallback api，浏览器空闲的时候执行
  3、dom diff 树变成了链表，一个dom对应两个fiber，对应两个队列，这都是为找到被中断的任务重新执行
从架构角度来看，Fiber 是对 React 核心算法(即调和过程)的重写
从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是对Fiber 树结构的节点单位，也就是React 16 新架构下的虚拟DOM
原理：
  Fiber 把渲染任务更新过程拆分成多个子任务，每次只做一小部分，做完看是否有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续进行
  即可以中断和恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为React Element 对应的 Fiber 节点
  实现的方式的是 requestIdleCallback 方法：
    window.requestIdleCallback() 方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入相应
  首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前React未完成的任务，是一种合作式调度
  该实现过程是基于 Fiber 节点实现，作为静态的数据结构来说，每个Fiber节点对应一个 React element，保存了该组件的类型(函数组件、类组件、原生组件等等)、对应的DOM节点等信息
  作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作

## webpack

### 1、loader 和 plugins 区别
它们是两个完全不同的东西。loader负责处理源文件，如CSS、jsx文件，一次处理一个文件。而 plugins 并不直接操作单个文件，它直接对整个构建过程起作用。
  loader 文件、编译转换工具，将模块原内容按照需求转换成新内容
  plugins webpack的监听器，接受webpack下发的消息通知下发

### 2、图片处理常见的加载器有几种
* file-loader，默认情况下会根据图片生成对应的MD5散列的文件格式。
* url-loader，它类似于file-loader，但是url-loader可以根据自身文件的大小，来决定是否把转化为base64格式的DataUrl单独作为文件，也可以自定义对应的散列文件名。
* image-webpack-loader，提供压缩图片的功能。

### 3、webpack 核心概念
* entry(入口)：构建项目的起点，默认根目录为 ./src
* output(出口)：告诉 webpack 在哪里输出它打包好的代码以及如何命名，默认目录为 ./dist
* modules(模块)：在 webpack 中一切皆为模块，一个文件皆为一个模块。webpack 会从配置的 entry 开始递归找出所有依赖的模块
* chunk(代码块)：一个 chunk 由多个模块组合而成，用于代码合并和切割
* loader(模块转换器)：用于把模块原内容按照需求转换为新内容
* plugin(扩展插件)：在 webpack 构建流程中的特定时机广播出对应事件，插件可以监听这些事件的发生，在特定的时机做对应的事情

### 4、webpack 基本功能
* 代码转换：Typescript 编译成 JavaScript，SASS 转换为 CSS 等等
* 文件优化：压缩 JavaScript、CSS、html 代码，压缩合并图片
* 代码分割：提取多页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
* 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件
* 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器
* 代码校验：在代码提交到仓库前需要检测代码是否规范，以及单元测试是否通过
* 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统

### 5、webpack 层面代码优化
* webpack 对图片进行压缩
* 减少 ES6 转为 ES5 的冗余代码
* 提取公共代码
* 模板预编译
* 提取组件的CSS
* 优化 sourceMap
* 构建结果输出分析

### 6、提高 webpack 的构建速度
* 优化 loader 配置
  在使用loader时，可以通过配置 include、exclude、test属性来匹配文件，接触include、exclude规定哪些匹配应用loader
* 优化 resolve.modules
  当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下，所以可以指明存在第三方模块的绝对路径，以减少查询
* 优化 resolve.alias
  通过配置 alias 减少查找过程
* 使用 cache-loader
  在一些性能开销大的 loader 之前添加 cache-loader，以将结果缓存在磁盘里，显著提升二次构建速度
  保存和读取这些缓存文件会有一定时间开销，所以请支队性能开销较大的loader使用
* terser 启动多线程
  使用多进程并行运行来提高构建速度


### 7、webpack proxy
解决跨域的原理：(服务器之前请求数据不会出现跨域行为，跨域行为是浏览器的安全策略限制)
  当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器
  目标服务器响应数据后再讲数据返回给代理服务器，最终再由代理服务器将数据响应给本地

## 库
* lodash 内置方法库
  [https://lodash.com/docs/4.17.15]

## 安全
1、XSS攻击的防范
  * HttpOnly 防止劫取 Cookie
  * 输入检查-不要相信用户的所有输入
  * 输出检查-存的时候转义或者编码

2、CSRF攻击的防范
  * 验证码
  * Referer Check
  * 添加token验证
